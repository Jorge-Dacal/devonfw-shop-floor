_[Under construction]_

'''
The purpose of the present document is to provide a high level description _(comparision vs. Kubernetes)_ of Spring Cloud Kubernetes, the solution implemented by Spring to integrate/deploy into a Kubernetes cluster a Spring Cloud Netflix microservices-based application/architecture.

'''

= Introduction

_[TODO]_

== Additional documentation
* link:http://blog.christianposta.com/microservices/netflix-oss-or-kubernetes-how-about-both/[Netflix OSS, Spring Cloud, or Kubernetes? How About All of Them!]
* link:http://blog.christianposta.com/microservices/the-hardest-part-of-microservices-calling-your-services/[The Hardest Part of Microservices: Calling Your Services]
* link:https://dzone.com/articles/deploying-microservices-spring-cloud-vs-kubernetes[Deploying Microservices: Spring Cloud vs. Kubernetes]
* link:https://dzone.com/articles/microservice-architecture-with-spring-cloud-and-do[Microservice Architectures With Spring Cloud and Docker]
* link:https://kubernetes.io/docs/concepts/services-networking/service/[Kubernetes Services]
* link:https://cloud.spring.io/spring-cloud-netflix/[Spring Cloud Netflix]
* link:https://github.com/spring-cloud-incubator/spring-cloud-kubernetes#ribbon-discovery-in-kubernetes[Spring Cloud Kubernetes]
* link:https://kubernetes.io/docs/concepts/services-networking/ingress/[Kubernetes Ingress Resources]
* link:https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/[Kubernetes DNS]
* link:https://devcentral.f5.com/articles/client-side-vs-server-side-load-balancing[Client-side vs Server-side Load Balancing]
* link:https://thenewstack.io/baker-street-avoiding-bottlenecks-with-a-client-side-load-balancer-for-microservices/[Avoiding Bottlenecks with a Client-Side Load Balancer for Microservices]
* link:https://github.com/devonfw/devon-guide/wiki/devon-microservices[Devon Framework Microservices]
* link:https://istio.io/[ISTIO]
* link:http://highscalability.com/blog/2016/1/4/server-side-architecture-front-end-servers-and-client-side-r.html[Server-Side Architecture. Front-End Servers And Client-Side Random Load Balancing]

= High level technology mapping

== Spring Cloud Netflix OSS vs. Kubernetes

{nbsp}
[%header,cols=3*]
|===
|CONCERN|Spring Cloud & Netflix OSS|Kubernetes

|||
|*Confi. Management*|Config. Server, Consul, Archaius|ConfigMap & Secrets
|*Service Discovery*|Eureka, Consul|Service & Ingress 
|*Load Balancing*|Ribbon|Service
|*API Gateway*|Zuul|Service & Ingress
|*Service Security*|Spring Cloud Security|
|*Centralized Logging*|ELK Stack (Log Stash)|EFK Stack (Fluentd)
|*Centralized Metrics*|Spectator & Atlas|Heapster, Prometheus, Grafana
|*Distributed Tracing*|Spring Cloud Sleuth, Zipkin|OpenTracing, Zipkin
|*Resilience & Fault Tolerance*|Hystrix, Turbine & Ribbon|Health Checks & resource isolation
|*Auto Scaling & Self Healing*||Heal Checks, Self Healing, Autoscaling
|*Packaging, Dep., & Scheduling*|Spring Boot|Docker/Rkt, Scheduler & Deployment
|*Job Management*|Spring batch|Jobs & Scheduled Jobs
|*Singleton Application*|Spring Cloud Cluster|Pods
|===

== Spring Cloud Kubernetes & Kubernetes

{nbsp}
[%header,cols=3*]
|===
|CONCERN|Spring Cloud & Netflix OSS|Kubernetes
|||
|*Config. Management*|`ConfigMapPropertySource`, `SecretsPropertySource`, Archaius|ConfigMap & Secrets
|*Service Discovery*|`DiscoveryClient`|Service & Ingress 
|*Resilience & Fault Tolerance*|HealthIndicator|Health Checks & resource isolation
|===

=== Config. Management
==== Properties
==== Secrets
==== Profiling

=== Service Discovery

From *inside* the cluster, Spring provides the `DiscoveryClient` implementation, which allows querying Kubernetes *Services by name* _(Notice that a Kubernetes *Service* is a logical agrupation of pods under the same IP and is exposed as a collection of endpoints to the applications/containers running as pods)_

Notice that, in order to allow this `DiscoveryClient` to work properly, the Kubernetes DNS service must be up & running in the Kubernetes cluster, so that every pods/container is able to resolve service names (see link:https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/[Kubernetes DNS]).

The `DicoveryClient` can be easly used just by

* *1st* addin the maven dependency

[source,xml]
----
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes</artifactId>
    <version>${latest.version}</version>
</dependency>
----
* *2nd* autowiring the bean

[source,java]
----
@Autowire
private DiscoveryClient discoveryClient;
----
* *3rd* setting the appropriate service instance name in the property
```
sprint.application.name
```
The `DiscoveryClient` can be disable with the property
```
spring.cloud.kubernetes.discovery.enabled=false
```
in which case, the discovery of the services would be carried out through the default Kubernetes Service.

Having the endpoints of a service in the client application/container allows the capability of Client-side load balancing.

From *outside* the Kubernetes client, the service discovery is still responsibility of Ingress (see link:https://kubernetes.io/docs/concepts/services-networking/ingress/[Kubernetes Ingress]).

==== Doubts/open points:
* Does the `DiscoveryClient` return list of services matching a name _(or pattern)_?
* Does the `DiscoveryClient` return list of all endpoints of a particular service?
* How the behavior is in case of discovering several different services? Does the `DiscoveryClient` maintain a _common single list_ of endpoints of all the services?
* In case of client-side load balancing, what should be the appropriate algorithm/method to determine which endpoint to target?
* A/B testing?

=== Resilience & Fault Tolerance

= Additional concerns

== Calls between services
* Adaptive routing / client side load balancing
* Automatic retries
* Timeout controls
* back pressure
* Rate limiting
* Metrics/stats collection
* Tracing
* A/B testing / traffic shaping / request shadowing
* Service refactoring / request shadowing
* Service deadline/timeout enforcement across service calls
* Security between services
* Edge gateway/router
* Surgical / fine / per-request routing
* Forced service isolation / outlier detection
* Fault injection (ie, injecting delays? dropping ingress/egress packets?)
* Internal releases/dark launches

= PROS & CONS
